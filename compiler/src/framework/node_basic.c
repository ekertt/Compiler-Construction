
/**
 * @file node_basic.c
 *
 * Functions to allocate node structures
 *
 * THIS FILE HAS BEEN GENERATED USING
 * $Id: node_basic.c.xsl 14593 2006-01-31 17:09:55Z cg $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

#include "node_basic.h"
#include "tree_basic.h"
#include "memory.h"
#include "dbug.h"
#include "globals.h"
#include "ctinfo.h"

static node    *
MakeEmptyNode()
{
	node           *result;

	DBUG_ENTER("MakeEmptyNode");

	result = (node *) MEMmalloc(sizeof(node));

	NODE_LINE(result) = global.line;
	NODE_COL(result) = global.col;

	DBUG_RETURN(result);
}



/*****************************************************************************
 * N_Program :
 *****************************************************************************/

node           *TBmakeProgram(node * Declarations) {
	node           *this;
	DBUG_ENTER("TBmakeProgram");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_program;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_program = MEMmalloc(sizeof(struct SONS_N_PROGRAM));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_program = MEMmalloc(sizeof(struct ATTRIBS_N_PROGRAM));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_program;
	DBUG_PRINT("MAKE", ("assigning son Declarations initial value: %s ", Declarations));
	PROGRAM_DECLARATIONS(this) = Declarations;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((PROGRAM_DECLARATIONS(this) != NULL) && (NODE_TYPE(PROGRAM_DECLARATIONS(this)) != N_declarations)) {
		CTIwarn("Field Declarations of node N_Program has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Declarations :
 *****************************************************************************/

node           *TBmakeDeclarations(node * Declaration, node * Next) {
	node           *this;
	DBUG_ENTER("TBmakeDeclarations");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_declarations;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_declarations = MEMmalloc(sizeof(struct SONS_N_DECLARATIONS));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_declarations = MEMmalloc(sizeof(struct ATTRIBS_N_DECLARATIONS));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_declarations;
	DBUG_PRINT("MAKE", ("assigning son Declaration initial value: %s ", Declaration));
	DECLARATIONS_DECLARATION(this) = Declaration;
	DBUG_PRINT("MAKE", ("assigning son Next initial value: %s ", Next));
	DECLARATIONS_NEXT(this) = Next;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((DECLARATIONS_DECLARATION(this) != NULL) && (NODE_TYPE(DECLARATIONS_DECLARATION(this)) != N_globaldef) && (NODE_TYPE(DECLARATIONS_DECLARATION(this)) != N_globaldec) && (NODE_TYPE(DECLARATIONS_DECLARATION(this)) != N_fundec) && (NODE_TYPE(DECLARATIONS_DECLARATION(this)) != N_fundef)) {
		CTIwarn("Field Declaration of node N_Declarations has non-allowed target node.");
	}
	if ((DECLARATIONS_NEXT(this) != NULL) && (NODE_TYPE(DECLARATIONS_NEXT(this)) != N_declarations)) {
		CTIwarn("Field Next of node N_Declarations has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_FunDec :
 *****************************************************************************/

node           *TBmakeFundec(type Type, node * FunHeader) {
	node           *this;
	DBUG_ENTER("TBmakeFundec");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_fundec;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_fundec = MEMmalloc(sizeof(struct SONS_N_FUNDEC));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_fundec = MEMmalloc(sizeof(struct ATTRIBS_N_FUNDEC));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_fundec;
	DBUG_PRINT("MAKE", ("assigning son FunHeader initial value: %s ", FunHeader));
	FUNDEC_FUNHEADER(this) = FunHeader;
	FUNDEC_TYPE(this) = Type;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((FUNDEC_FUNHEADER(this) != NULL) && (NODE_TYPE(FUNDEC_FUNHEADER(this)) != N_funheader)) {
		CTIwarn("Field FunHeader of node N_FunDec has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_FunDefs :
 *****************************************************************************/

node           *TBmakeFundefs(node * FunDef, node * Next) {
	node           *this;
	DBUG_ENTER("TBmakeFundefs");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_fundefs;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_fundefs = MEMmalloc(sizeof(struct SONS_N_FUNDEFS));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_fundefs = MEMmalloc(sizeof(struct ATTRIBS_N_FUNDEFS));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_fundefs;
	DBUG_PRINT("MAKE", ("assigning son FunDef initial value: %s ", FunDef));
	FUNDEFS_FUNDEF(this) = FunDef;
	DBUG_PRINT("MAKE", ("assigning son Next initial value: %s ", Next));
	FUNDEFS_NEXT(this) = Next;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((FUNDEFS_FUNDEF(this) != NULL) && (NODE_TYPE(FUNDEFS_FUNDEF(this)) != N_fundef)) {
		CTIwarn("Field FunDef of node N_FunDefs has non-allowed target node.");
	}
	if ((FUNDEFS_NEXT(this) != NULL) && (NODE_TYPE(FUNDEFS_NEXT(this)) != N_fundefs)) {
		CTIwarn("Field Next of node N_FunDefs has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_FunDef :
 *****************************************************************************/

node           *TBmakeFundef(type Type, node * FunBody, node * FunHeader, node * Params) {
	node           *this;
	DBUG_ENTER("TBmakeFundef");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_fundef;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_fundef = MEMmalloc(sizeof(struct SONS_N_FUNDEF));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_fundef = MEMmalloc(sizeof(struct ATTRIBS_N_FUNDEF));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_fundef;
	DBUG_PRINT("MAKE", ("assigning son FunBody initial value: %s ", FunBody));
	FUNDEF_FUNBODY(this) = FunBody;
	DBUG_PRINT("MAKE", ("assigning son FunHeader initial value: %s ", FunHeader));
	FUNDEF_FUNHEADER(this) = FunHeader;
	DBUG_PRINT("MAKE", ("assigning son Params initial value: %s ", Params));
	FUNDEF_PARAMS(this) = Params;
	FUNDEF_TYPE(this) = Type;
	FUNDEF_ISEXTERN(this) = FALSE;
	FUNDEF_ISEXPORT(this) = FALSE;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((FUNDEF_FUNBODY(this) != NULL) && (NODE_TYPE(FUNDEF_FUNBODY(this)) != N_funbody)) {
		CTIwarn("Field FunBody of node N_FunDef has non-allowed target node.");
	}
	if ((FUNDEF_FUNHEADER(this) != NULL) && (NODE_TYPE(FUNDEF_FUNHEADER(this)) != N_funheader)) {
		CTIwarn("Field FunHeader of node N_FunDef has non-allowed target node.");
	}
	if ((FUNDEF_PARAMS(this) != NULL) && (NODE_TYPE(FUNDEF_PARAMS(this)) != N_param)) {
		CTIwarn("Field Params of node N_FunDef has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_FunHeader :
 *****************************************************************************/

node           *TBmakeFunheader(type Type, node * Param) {
	node           *this;
	DBUG_ENTER("TBmakeFunheader");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_funheader;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_funheader = MEMmalloc(sizeof(struct SONS_N_FUNHEADER));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_funheader = MEMmalloc(sizeof(struct ATTRIBS_N_FUNHEADER));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_funheader;
	DBUG_PRINT("MAKE", ("assigning son Param initial value: %s ", Param));
	FUNHEADER_PARAM(this) = Param;
	FUNHEADER_TYPE(this) = Type;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((FUNHEADER_PARAM(this) != NULL) && (NODE_TYPE(FUNHEADER_PARAM(this)) != N_param)) {
		CTIwarn("Field Param of node N_FunHeader has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_GlobalDec :
 *****************************************************************************/

node           *TBmakeGlobaldec(type Type, node * Ids) {
	node           *this;
	DBUG_ENTER("TBmakeGlobaldec");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_globaldec;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_globaldec = MEMmalloc(sizeof(struct SONS_N_GLOBALDEC));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_globaldec = MEMmalloc(sizeof(struct ATTRIBS_N_GLOBALDEC));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_globaldec;
	DBUG_PRINT("MAKE", ("assigning son Ids initial value: %s ", Ids));
	GLOBALDEC_IDS(this) = Ids;
	GLOBALDEC_TYPE(this) = Type;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((GLOBALDEC_IDS(this) != NULL) && (NODE_TYPE(GLOBALDEC_IDS(this)) != N_expressions)) {
		CTIwarn("Field Ids of node N_GlobalDec has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_GlobalDef :
 *****************************************************************************/

node           *TBmakeGlobaldef(type Type, node * Ids) {
	node           *this;
	DBUG_ENTER("TBmakeGlobaldef");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_globaldef;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_globaldef = MEMmalloc(sizeof(struct SONS_N_GLOBALDEF));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_globaldef = MEMmalloc(sizeof(struct ATTRIBS_N_GLOBALDEF));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_globaldef;
	DBUG_PRINT("MAKE", ("assigning son Ids initial value: %s ", Ids));
	GLOBALDEF_IDS(this) = Ids;
	GLOBALDEF_TYPE(this) = Type;
	GLOBALDEF_ISEXPORT(this) = FALSE;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((GLOBALDEF_IDS(this) != NULL) && (NODE_TYPE(GLOBALDEF_IDS(this)) != N_expressions)) {
		CTIwarn("Field Ids of node N_GlobalDef has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Param :
 *****************************************************************************/

node           *TBmakeParam(type Type, node * Id, node * Next) {
	node           *this;
	DBUG_ENTER("TBmakeParam");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_param;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_param = MEMmalloc(sizeof(struct SONS_N_PARAM));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_param = MEMmalloc(sizeof(struct ATTRIBS_N_PARAM));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_param;
	DBUG_PRINT("MAKE", ("assigning son Id initial value: %s ", Id));
	PARAM_ID(this) = Id;
	DBUG_PRINT("MAKE", ("assigning son Next initial value: %s ", Next));
	PARAM_NEXT(this) = Next;
	PARAM_TYPE(this) = Type;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((PARAM_ID(this) != NULL) && (NODE_TYPE(PARAM_ID(this)) != N_ids)) {
		CTIwarn("Field Id of node N_Param has non-allowed target node.");
	}
	if ((PARAM_NEXT(this) != NULL) && (NODE_TYPE(PARAM_NEXT(this)) != N_param)) {
		CTIwarn("Field Next of node N_Param has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_FunBody :
 *****************************************************************************/

node           *TBmakeFunbody(node * Vardec, node * LocalFundefs, node * Stmts) {
	node           *this;
	DBUG_ENTER("TBmakeFunbody");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_funbody;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_funbody = MEMmalloc(sizeof(struct SONS_N_FUNBODY));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_funbody = MEMmalloc(sizeof(struct ATTRIBS_N_FUNBODY));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_funbody;
	DBUG_PRINT("MAKE", ("assigning son Vardec initial value: %s ", Vardec));
	FUNBODY_VARDEC(this) = Vardec;
	DBUG_PRINT("MAKE", ("assigning son LocalFundefs initial value: %s ", LocalFundefs));
	FUNBODY_LOCALFUNDEFS(this) = LocalFundefs;
	DBUG_PRINT("MAKE", ("assigning son Stmts initial value: %s ", Stmts));
	FUNBODY_STMTS(this) = Stmts;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((FUNBODY_VARDEC(this) != NULL) && (NODE_TYPE(FUNBODY_VARDEC(this)) != N_vardec)) {
		CTIwarn("Field Vardec of node N_FunBody has non-allowed target node.");
	}
	if ((FUNBODY_LOCALFUNDEFS(this) != NULL) && (NODE_TYPE(FUNBODY_LOCALFUNDEFS(this)) != N_fundefs)) {
		CTIwarn("Field LocalFundefs of node N_FunBody has non-allowed target node.");
	}
	if ((FUNBODY_STMTS(this) != NULL) && (NODE_TYPE(FUNBODY_STMTS(this)) != N_stmts)) {
		CTIwarn("Field Stmts of node N_FunBody has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_VarDec :
 *****************************************************************************/

node           *TBmakeVardec(type Type, node * Expressions, node * Next) {
	node           *this;
	DBUG_ENTER("TBmakeVardec");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_vardec;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_vardec = MEMmalloc(sizeof(struct SONS_N_VARDEC));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_vardec = MEMmalloc(sizeof(struct ATTRIBS_N_VARDEC));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_vardec;
	DBUG_PRINT("MAKE", ("assigning son Expressions initial value: %s ", Expressions));
	VARDEC_EXPRESSIONS(this) = Expressions;
	DBUG_PRINT("MAKE", ("assigning son Next initial value: %s ", Next));
	VARDEC_NEXT(this) = Next;
	VARDEC_TYPE(this) = Type;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((VARDEC_EXPRESSIONS(this) != NULL) && (NODE_TYPE(VARDEC_EXPRESSIONS(this)) != N_expressions)) {
		CTIwarn("Field Expressions of node N_VarDec has non-allowed target node.");
	}
	if ((VARDEC_NEXT(this) != NULL) && (NODE_TYPE(VARDEC_NEXT(this)) != N_vardec)) {
		CTIwarn("Field Next of node N_VarDec has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_IfElse :
 *****************************************************************************/

node           *TBmakeIfelse(node * Condition, node * Then, node * Else) {
	node           *this;
	DBUG_ENTER("TBmakeIfelse");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_ifelse;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_ifelse = MEMmalloc(sizeof(struct SONS_N_IFELSE));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_ifelse = MEMmalloc(sizeof(struct ATTRIBS_N_IFELSE));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_ifelse;
	DBUG_PRINT("MAKE", ("assigning son Condition initial value: %s ", Condition));
	IFELSE_CONDITION(this) = Condition;
	DBUG_PRINT("MAKE", ("assigning son Then initial value: %s ", Then));
	IFELSE_THEN(this) = Then;
	DBUG_PRINT("MAKE", ("assigning son Else initial value: %s ", Else));
	IFELSE_ELSE(this) = Else;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((IFELSE_CONDITION(this) != NULL) && (NODE_TYPE(IFELSE_CONDITION(this)) != N_binop) && (NODE_TYPE(IFELSE_CONDITION(this)) != N_monop) && (NODE_TYPE(IFELSE_CONDITION(this)) != N_var) && (NODE_TYPE(IFELSE_CONDITION(this)) != N_num) && (NODE_TYPE(IFELSE_CONDITION(this)) != N_float) && (NODE_TYPE(IFELSE_CONDITION(this)) != N_bool)) {
		CTIwarn("Field Condition of node N_IfElse has non-allowed target node.");
	}
	if ((IFELSE_THEN(this) != NULL) && (NODE_TYPE(IFELSE_THEN(this)) != N_stmts)) {
		CTIwarn("Field Then of node N_IfElse has non-allowed target node.");
	}
	if ((IFELSE_ELSE(this) != NULL) && (NODE_TYPE(IFELSE_ELSE(this)) != N_stmts)) {
		CTIwarn("Field Else of node N_IfElse has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_While :
 *****************************************************************************/

node           *TBmakeWhile(node * Condition, node * Block) {
	node           *this;
	DBUG_ENTER("TBmakeWhile");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_while;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_while = MEMmalloc(sizeof(struct SONS_N_WHILE));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_while = MEMmalloc(sizeof(struct ATTRIBS_N_WHILE));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_while;
	DBUG_PRINT("MAKE", ("assigning son Condition initial value: %s ", Condition));
	WHILE_CONDITION(this) = Condition;
	DBUG_PRINT("MAKE", ("assigning son Block initial value: %s ", Block));
	WHILE_BLOCK(this) = Block;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((WHILE_CONDITION(this) != NULL) && (NODE_TYPE(WHILE_CONDITION(this)) != N_binop) && (NODE_TYPE(WHILE_CONDITION(this)) != N_monop) && (NODE_TYPE(WHILE_CONDITION(this)) != N_var) && (NODE_TYPE(WHILE_CONDITION(this)) != N_num) && (NODE_TYPE(WHILE_CONDITION(this)) != N_float) && (NODE_TYPE(WHILE_CONDITION(this)) != N_bool)) {
		CTIwarn("Field Condition of node N_While has non-allowed target node.");
	}
	if ((WHILE_BLOCK(this) != NULL) && (NODE_TYPE(WHILE_BLOCK(this)) != N_stmts)) {
		CTIwarn("Field Block of node N_While has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_DoWhile :
 *****************************************************************************/

node           *TBmakeDowhile(node * Condition, node * Block) {
	node           *this;
	DBUG_ENTER("TBmakeDowhile");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_dowhile;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_dowhile = MEMmalloc(sizeof(struct SONS_N_DOWHILE));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_dowhile = MEMmalloc(sizeof(struct ATTRIBS_N_DOWHILE));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_dowhile;
	DBUG_PRINT("MAKE", ("assigning son Condition initial value: %s ", Condition));
	DOWHILE_CONDITION(this) = Condition;
	DBUG_PRINT("MAKE", ("assigning son Block initial value: %s ", Block));
	DOWHILE_BLOCK(this) = Block;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((DOWHILE_CONDITION(this) != NULL) && (NODE_TYPE(DOWHILE_CONDITION(this)) != N_binop) && (NODE_TYPE(DOWHILE_CONDITION(this)) != N_monop) && (NODE_TYPE(DOWHILE_CONDITION(this)) != N_var) && (NODE_TYPE(DOWHILE_CONDITION(this)) != N_num) && (NODE_TYPE(DOWHILE_CONDITION(this)) != N_float) && (NODE_TYPE(DOWHILE_CONDITION(this)) != N_bool)) {
		CTIwarn("Field Condition of node N_DoWhile has non-allowed target node.");
	}
	if ((DOWHILE_BLOCK(this) != NULL) && (NODE_TYPE(DOWHILE_BLOCK(this)) != N_stmts)) {
		CTIwarn("Field Block of node N_DoWhile has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_For :
 *****************************************************************************/

node           *TBmakeFor(node * First, node * Second, node * Third, node * Block) {
	node           *this;
	DBUG_ENTER("TBmakeFor");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_for;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_for = MEMmalloc(sizeof(struct SONS_N_FOR));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_for = MEMmalloc(sizeof(struct ATTRIBS_N_FOR));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_for;
	DBUG_PRINT("MAKE", ("assigning son First initial value: %s ", First));
	FOR_FIRST(this) = First;
	DBUG_PRINT("MAKE", ("assigning son Second initial value: %s ", Second));
	FOR_SECOND(this) = Second;
	DBUG_PRINT("MAKE", ("assigning son Third initial value: %s ", Third));
	FOR_THIRD(this) = Third;
	DBUG_PRINT("MAKE", ("assigning son Block initial value: %s ", Block));
	FOR_BLOCK(this) = Block;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((FOR_FIRST(this) != NULL) && (NODE_TYPE(FOR_FIRST(this)) != N_binop) && (NODE_TYPE(FOR_FIRST(this)) != N_monop) && (NODE_TYPE(FOR_FIRST(this)) != N_var) && (NODE_TYPE(FOR_FIRST(this)) != N_num) && (NODE_TYPE(FOR_FIRST(this)) != N_float) && (NODE_TYPE(FOR_FIRST(this)) != N_bool)) {
		CTIwarn("Field First of node N_For has non-allowed target node.");
	}
	if ((FOR_SECOND(this) != NULL) && (NODE_TYPE(FOR_SECOND(this)) != N_binop) && (NODE_TYPE(FOR_SECOND(this)) != N_monop) && (NODE_TYPE(FOR_SECOND(this)) != N_var) && (NODE_TYPE(FOR_SECOND(this)) != N_num) && (NODE_TYPE(FOR_SECOND(this)) != N_float) && (NODE_TYPE(FOR_SECOND(this)) != N_bool)) {
		CTIwarn("Field Second of node N_For has non-allowed target node.");
	}
	if ((FOR_THIRD(this) != NULL) && (NODE_TYPE(FOR_THIRD(this)) != N_binop) && (NODE_TYPE(FOR_THIRD(this)) != N_monop) && (NODE_TYPE(FOR_THIRD(this)) != N_var) && (NODE_TYPE(FOR_THIRD(this)) != N_num) && (NODE_TYPE(FOR_THIRD(this)) != N_float) && (NODE_TYPE(FOR_THIRD(this)) != N_bool)) {
		CTIwarn("Field Third of node N_For has non-allowed target node.");
	}
	if ((FOR_BLOCK(this) != NULL) && (NODE_TYPE(FOR_BLOCK(this)) != N_stmts)) {
		CTIwarn("Field Block of node N_For has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Return :
 *****************************************************************************/

node           *TBmakeReturn(node * Expr) {
	node           *this;
	DBUG_ENTER("TBmakeReturn");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_return;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_return = MEMmalloc(sizeof(struct SONS_N_RETURN));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_return = MEMmalloc(sizeof(struct ATTRIBS_N_RETURN));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_return;
	DBUG_PRINT("MAKE", ("assigning son Expr initial value: %s ", Expr));
	RETURN_EXPR(this) = Expr;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((RETURN_EXPR(this) != NULL) && (NODE_TYPE(RETURN_EXPR(this)) != N_binop) && (NODE_TYPE(RETURN_EXPR(this)) != N_monop) && (NODE_TYPE(RETURN_EXPR(this)) != N_var) && (NODE_TYPE(RETURN_EXPR(this)) != N_num) && (NODE_TYPE(RETURN_EXPR(this)) != N_float) && (NODE_TYPE(RETURN_EXPR(this)) != N_bool)) {
		CTIwarn("Field Expr of node N_Return has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Expressions :
 *****************************************************************************/

node           *TBmakeExpressions(node * Expr, node * Next) {
	node           *this;
	DBUG_ENTER("TBmakeExpressions");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_expressions;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_expressions = MEMmalloc(sizeof(struct SONS_N_EXPRESSIONS));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_expressions = MEMmalloc(sizeof(struct ATTRIBS_N_EXPRESSIONS));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_expressions;
	DBUG_PRINT("MAKE", ("assigning son Expr initial value: %s ", Expr));
	EXPRESSIONS_EXPR(this) = Expr;
	DBUG_PRINT("MAKE", ("assigning son Next initial value: %s ", Next));
	EXPRESSIONS_NEXT(this) = Next;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((EXPRESSIONS_EXPR(this) != NULL) && (NODE_TYPE(EXPRESSIONS_EXPR(this)) != N_binop) && (NODE_TYPE(EXPRESSIONS_EXPR(this)) != N_monop) && (NODE_TYPE(EXPRESSIONS_EXPR(this)) != N_var) && (NODE_TYPE(EXPRESSIONS_EXPR(this)) != N_num) && (NODE_TYPE(EXPRESSIONS_EXPR(this)) != N_float) && (NODE_TYPE(EXPRESSIONS_EXPR(this)) != N_bool)) {
		CTIwarn("Field Expr of node N_Expressions has non-allowed target node.");
	}
	if ((EXPRESSIONS_NEXT(this) != NULL) && (NODE_TYPE(EXPRESSIONS_NEXT(this)) != N_expressions)) {
		CTIwarn("Field Next of node N_Expressions has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Ids :
 *****************************************************************************/

node           *TBmakeIds(node * Expr) {
	node           *this;
	DBUG_ENTER("TBmakeIds");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_ids;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_ids = MEMmalloc(sizeof(struct SONS_N_IDS));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_ids = MEMmalloc(sizeof(struct ATTRIBS_N_IDS));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_ids;
	DBUG_PRINT("MAKE", ("assigning son Expr initial value: %s ", Expr));
	IDS_EXPR(this) = Expr;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((IDS_EXPR(this) != NULL) && (NODE_TYPE(IDS_EXPR(this)) != N_binop) && (NODE_TYPE(IDS_EXPR(this)) != N_monop) && (NODE_TYPE(IDS_EXPR(this)) != N_var) && (NODE_TYPE(IDS_EXPR(this)) != N_num) && (NODE_TYPE(IDS_EXPR(this)) != N_float) && (NODE_TYPE(IDS_EXPR(this)) != N_bool)) {
		CTIwarn("Field Expr of node N_Ids has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Stmts :
 *****************************************************************************/

node           *TBmakeStmts(node * Stmt, node * Next) {
	node           *this;
	DBUG_ENTER("TBmakeStmts");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_stmts;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_stmts = MEMmalloc(sizeof(struct SONS_N_STMTS));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_stmts = MEMmalloc(sizeof(struct ATTRIBS_N_STMTS));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_stmts;
	DBUG_PRINT("MAKE", ("assigning son Stmt initial value: %s ", Stmt));
	STMTS_STMT(this) = Stmt;
	DBUG_PRINT("MAKE", ("assigning son Next initial value: %s ", Next));
	STMTS_NEXT(this) = Next;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((STMTS_STMT(this) != NULL) && (NODE_TYPE(STMTS_STMT(this)) != N_assign) && (NODE_TYPE(STMTS_STMT(this)) != N_ifelse) && (NODE_TYPE(STMTS_STMT(this)) != N_while) && (NODE_TYPE(STMTS_STMT(this)) != N_dowhile) && (NODE_TYPE(STMTS_STMT(this)) != N_for) && (NODE_TYPE(STMTS_STMT(this)) != N_return)) {
		CTIwarn("Field Stmt of node N_Stmts has non-allowed target node.");
	}
	if ((STMTS_NEXT(this) != NULL) && (NODE_TYPE(STMTS_NEXT(this)) != N_stmts)) {
		CTIwarn("Field Next of node N_Stmts has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Assign :
 *****************************************************************************/

node           *TBmakeAssign(node * Let, node * Expr) {
	node           *this;
	DBUG_ENTER("TBmakeAssign");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_assign;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_assign = MEMmalloc(sizeof(struct SONS_N_ASSIGN));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_assign = MEMmalloc(sizeof(struct ATTRIBS_N_ASSIGN));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_assign;
	DBUG_PRINT("MAKE", ("assigning son Let initial value: %s ", Let));
	ASSIGN_LET(this) = Let;
	DBUG_PRINT("MAKE", ("assigning son Expr initial value: %s ", Expr));
	ASSIGN_EXPR(this) = Expr;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((ASSIGN_LET(this) != NULL) && (NODE_TYPE(ASSIGN_LET(this)) != N_varlet)) {
		CTIwarn("Field Let of node N_Assign has non-allowed target node.");
	}
	if ((ASSIGN_EXPR(this) != NULL) && (NODE_TYPE(ASSIGN_EXPR(this)) != N_binop) && (NODE_TYPE(ASSIGN_EXPR(this)) != N_monop) && (NODE_TYPE(ASSIGN_EXPR(this)) != N_var) && (NODE_TYPE(ASSIGN_EXPR(this)) != N_num) && (NODE_TYPE(ASSIGN_EXPR(this)) != N_float) && (NODE_TYPE(ASSIGN_EXPR(this)) != N_bool)) {
		CTIwarn("Field Expr of node N_Assign has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_BinOp :
 *****************************************************************************/

node           *TBmakeBinop(binop Op, node * Left, node * Right) {
	node           *this;
	DBUG_ENTER("TBmakeBinop");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_binop;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_binop = MEMmalloc(sizeof(struct SONS_N_BINOP));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_binop = MEMmalloc(sizeof(struct ATTRIBS_N_BINOP));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_binop;
	DBUG_PRINT("MAKE", ("assigning son Left initial value: %s ", Left));
	BINOP_LEFT(this) = Left;
	DBUG_PRINT("MAKE", ("assigning son Right initial value: %s ", Right));
	BINOP_RIGHT(this) = Right;
	BINOP_OP(this) = Op;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((BINOP_LEFT(this) != NULL) && (NODE_TYPE(BINOP_LEFT(this)) != N_binop) && (NODE_TYPE(BINOP_LEFT(this)) != N_monop) && (NODE_TYPE(BINOP_LEFT(this)) != N_var) && (NODE_TYPE(BINOP_LEFT(this)) != N_num) && (NODE_TYPE(BINOP_LEFT(this)) != N_float) && (NODE_TYPE(BINOP_LEFT(this)) != N_bool)) {
		CTIwarn("Field Left of node N_BinOp has non-allowed target node.");
	}
	if ((BINOP_RIGHT(this) != NULL) && (NODE_TYPE(BINOP_RIGHT(this)) != N_binop) && (NODE_TYPE(BINOP_RIGHT(this)) != N_monop) && (NODE_TYPE(BINOP_RIGHT(this)) != N_var) && (NODE_TYPE(BINOP_RIGHT(this)) != N_num) && (NODE_TYPE(BINOP_RIGHT(this)) != N_float) && (NODE_TYPE(BINOP_RIGHT(this)) != N_bool)) {
		CTIwarn("Field Right of node N_BinOp has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_MonOp :
 *****************************************************************************/

node           *TBmakeMonop(monop Op, node * Operand) {
	node           *this;
	DBUG_ENTER("TBmakeMonop");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_monop;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_monop = MEMmalloc(sizeof(struct SONS_N_MONOP));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_monop = MEMmalloc(sizeof(struct ATTRIBS_N_MONOP));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_monop;
	DBUG_PRINT("MAKE", ("assigning son Operand initial value: %s ", Operand));
	MONOP_OPERAND(this) = Operand;
	MONOP_OP(this) = Op;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((MONOP_OPERAND(this) != NULL) && (NODE_TYPE(MONOP_OPERAND(this)) != N_binop) && (NODE_TYPE(MONOP_OPERAND(this)) != N_monop) && (NODE_TYPE(MONOP_OPERAND(this)) != N_var) && (NODE_TYPE(MONOP_OPERAND(this)) != N_num) && (NODE_TYPE(MONOP_OPERAND(this)) != N_float) && (NODE_TYPE(MONOP_OPERAND(this)) != N_bool)) {
		CTIwarn("Field Operand of node N_MonOp has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_VarLet :
 *****************************************************************************/

node           *TBmakeVarlet(char *Name){
	node           *this;
	DBUG_ENTER("TBmakeVarlet");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_varlet;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_varlet = MEMmalloc(sizeof(struct SONS_N_VARLET));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_varlet = MEMmalloc(sizeof(struct ATTRIBS_N_VARLET));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_varlet;
	VARLET_NAME(this) = Name;
	VARLET_DECL(this) = NULL;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Var :
 *****************************************************************************/

node           *TBmakeVar(char *Name){
	node           *this;
	DBUG_ENTER("TBmakeVar");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_var;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_var = MEMmalloc(sizeof(struct SONS_N_VAR));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_var = MEMmalloc(sizeof(struct ATTRIBS_N_VAR));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_var;
	VAR_NAME(this) = Name;
	VAR_DECL(this) = NULL;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Num :
 *****************************************************************************/

node           *TBmakeNum(int Value){
	node           *this;
	DBUG_ENTER("TBmakeNum");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_num;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_num = MEMmalloc(sizeof(struct SONS_N_NUM));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_num = MEMmalloc(sizeof(struct ATTRIBS_N_NUM));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_num;
	NUM_VALUE(this) = Value;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Float :
 *****************************************************************************/

node           *TBmakeFloat(float Value){
	node           *this;
	DBUG_ENTER("TBmakeFloat");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_float;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_float = MEMmalloc(sizeof(struct SONS_N_FLOAT));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_float = MEMmalloc(sizeof(struct ATTRIBS_N_FLOAT));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_float;
	FLOAT_VALUE(this) = Value;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Bool :
 *****************************************************************************/

node           *TBmakeBool(bool Value) {
	node           *this;
	DBUG_ENTER("TBmakeBool");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_bool;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_bool = MEMmalloc(sizeof(struct SONS_N_BOOL));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_bool = MEMmalloc(sizeof(struct ATTRIBS_N_BOOL));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_bool;
	BOOL_VALUE(this) = Value;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_SymbolTableEntry :
 *****************************************************************************/

node           *TBmakeSymboltableentry() {
	node           *this;
	DBUG_ENTER("TBmakeSymboltableentry");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_symboltableentry;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_symboltableentry = MEMmalloc(sizeof(struct SONS_N_SYMBOLTABLEENTRY));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_symboltableentry = MEMmalloc(sizeof(struct ATTRIBS_N_SYMBOLTABLEENTRY));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_symboltableentry;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}

/*****************************************************************************
 * N_Error :
 *****************************************************************************/

node           *TBmakeError(char *message, compiler_phase_t anyphase, node * Next){
	node           *this;
	DBUG_ENTER("TBmakeError");
	DBUG_PRINT("MAKE", ("allocating node structure"));
	this = MakeEmptyNode();
	NODE_TYPE(this) = N_error;
	DBUG_PRINT("MAKE", ("address: %s ", this));
	DBUG_PRINT("MAKE", ("allocating sons structure"));
	this->sons.N_error = MEMmalloc(sizeof(struct SONS_N_ERROR));
	DBUG_PRINT("MAKE", ("allocating attrib structure"));
	this->attribs.N_error = MEMmalloc(sizeof(struct ATTRIBS_N_ERROR));
	DBUG_PRINT("MAKE", ("setting node type"));
	NODE_TYPE(this) = N_error;
	DBUG_PRINT("MAKE", ("assigning son Next initial value: %s ", Next));
	ERROR_NEXT(this) = Next;
	ERROR_MESSAGE(this) = message;
	ERROR_ANYPHASE(this) = anyphase;
#ifndef DBUG_OFF
	DBUG_PRINT("MAKE", ("doing son target checks"));
	if ((ERROR_NEXT(this) != NULL) && (NODE_TYPE(ERROR_NEXT(this)) != N_error)) {
		CTIwarn("Field Next of node N_Error has non-allowed target node.");
	}
#endif				/* DBUG_OFF */
	DBUG_RETURN(this);
}
/* end of file */

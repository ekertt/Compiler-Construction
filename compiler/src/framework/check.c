
/**
 * @file check.c
 *
 * Functions needed by check.
 *
 * THIS FILE HAS BEEN GENERATED USING
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node           *
CHKdoTreeCheck(node * syntax_tree)
{
	DBUG_ENTER("CHKdoTreeCheck");

	DBUG_PRINT("CHK", ("Starting the check mechanism"));

	TRAVpush(TR_chk);
	syntax_tree = TRAVdo(syntax_tree, NULL);
	TRAVpop();

	DBUG_PRINT("CHK", ("Checkmechanism complete"));

	DBUG_RETURN(syntax_tree);
}

static bool 
isDeclaration(node * arg_node)
{
	bool		res = ((NODE_TYPE(arg_node) == N_fundec) ||
		     (NODE_TYPE(arg_node) == N_fundef) ||
		     (NODE_TYPE(arg_node) == N_globaldec) ||
		     (NODE_TYPE(arg_node) == N_globaldef));
	return (res);
}
static bool 
isExpr(node * arg_node)
{
	bool		res = ((NODE_TYPE(arg_node) == N_binop) ||
		     (NODE_TYPE(arg_node) == N_bool) ||
		     (NODE_TYPE(arg_node) == N_float) ||
		     (NODE_TYPE(arg_node) == N_monop) ||
		     (NODE_TYPE(arg_node) == N_num) ||
		     (NODE_TYPE(arg_node) == N_var));
	return (res);
}
static bool 
isStmt(node * arg_node)
{
	bool		res = ((NODE_TYPE(arg_node) == N_assign) ||
		     (NODE_TYPE(arg_node) == N_dowhile) ||
		     (NODE_TYPE(arg_node) == N_for) ||
		     (NODE_TYPE(arg_node) == N_ifelse) ||
		     (NODE_TYPE(arg_node) == N_return) ||
		     (NODE_TYPE(arg_node) == N_while));
	return (res);
}
void		isDummy   () {
	isDeclaration(NULL);
	isExpr(NULL);
	isStmt(NULL);
}
/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKassign(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKassign");

	/*
	 * Son check: ASSIGN_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(ASSIGN_EXPR(arg_node), arg_node, "mandatory son ASSIGN_EXPR is NULL");
		if (ASSIGN_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(ASSIGN_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "ASSIGN_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(ASSIGN_EXPR(arg_node), arg_node, "attribute ASSIGN_EXPR must be NULL");
	}

	/*
	 * Son check: ASSIGN_LET
	 */
	if ((FALSE) || (TRUE)) {
		if (ASSIGN_LET(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(ASSIGN_LET(arg_node)) == N_varlet))) {
				CHKcorrectTypeInsertError(arg_node, "ASSIGN_LET hasnt the right type." " It should be: " "N_varlet");
			}
		}
	} else {
		CHKnotExist(ASSIGN_LET(arg_node), arg_node, "attribute ASSIGN_LET must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (ASSIGN_EXPR(arg_node) != NULL) {
		ASSIGN_EXPR(arg_node) = TRAVdo(ASSIGN_EXPR(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (ASSIGN_LET(arg_node) != NULL) {
		ASSIGN_LET(arg_node) = TRAVdo(ASSIGN_LET(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKbinop(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKbinop");

	/*
	 * Son check: BINOP_LEFT
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(BINOP_LEFT(arg_node), arg_node, "mandatory son BINOP_LEFT is NULL");
		if (BINOP_LEFT(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(BINOP_LEFT(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "BINOP_LEFT hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(BINOP_LEFT(arg_node), arg_node, "attribute BINOP_LEFT must be NULL");
	}

	/*
	 * Son check: BINOP_RIGHT
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(BINOP_RIGHT(arg_node), arg_node, "mandatory son BINOP_RIGHT is NULL");
		if (BINOP_RIGHT(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(BINOP_RIGHT(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "BINOP_RIGHT hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(BINOP_RIGHT(arg_node), arg_node, "attribute BINOP_RIGHT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (BINOP_LEFT(arg_node) != NULL) {
		BINOP_LEFT(arg_node) = TRAVdo(BINOP_LEFT(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (BINOP_RIGHT(arg_node) != NULL) {
		BINOP_RIGHT(arg_node) = TRAVdo(BINOP_RIGHT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKbool(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKbool");
	DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKdeclarations
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Declarations node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKdeclarations(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKdeclarations");

	/*
	 * Son check: DECLARATIONS_DECLARATION
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(DECLARATIONS_DECLARATION(arg_node), arg_node, "mandatory son DECLARATIONS_DECLARATION is NULL");
		if (DECLARATIONS_DECLARATION(arg_node) != NULL) {
			if (!((FALSE) || (isDeclaration(DECLARATIONS_DECLARATION(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "DECLARATIONS_DECLARATION hasnt the right type." " It should be: " "Nodeset: Declaration");
			}
		}
	} else {
		CHKnotExist(DECLARATIONS_DECLARATION(arg_node), arg_node, "attribute DECLARATIONS_DECLARATION must be NULL");
	}

	/*
	 * Son check: DECLARATIONS_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (DECLARATIONS_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(DECLARATIONS_NEXT(arg_node)) == N_declarations))) {
				CHKcorrectTypeInsertError(arg_node, "DECLARATIONS_NEXT hasnt the right type." " It should be: " "N_declarations");
			}
		}
	} else {
		CHKnotExist(DECLARATIONS_NEXT(arg_node), arg_node, "attribute DECLARATIONS_NEXT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (DECLARATIONS_DECLARATION(arg_node) != NULL) {
		DECLARATIONS_DECLARATION(arg_node) = TRAVdo(DECLARATIONS_DECLARATION(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (DECLARATIONS_NEXT(arg_node) != NULL) {
		DECLARATIONS_NEXT(arg_node) = TRAVdo(DECLARATIONS_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKdowhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhile node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKdowhile(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKdowhile");

	/*
	 * Son check: DOWHILE_BLOCK
	 */
	if ((FALSE) || (TRUE)) {
		if (DOWHILE_BLOCK(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(DOWHILE_BLOCK(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "DOWHILE_BLOCK hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(DOWHILE_BLOCK(arg_node), arg_node, "attribute DOWHILE_BLOCK must be NULL");
	}

	/*
	 * Son check: DOWHILE_CONDITION
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(DOWHILE_CONDITION(arg_node), arg_node, "mandatory son DOWHILE_CONDITION is NULL");
		if (DOWHILE_CONDITION(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(DOWHILE_CONDITION(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "DOWHILE_CONDITION hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(DOWHILE_CONDITION(arg_node), arg_node, "attribute DOWHILE_CONDITION must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (DOWHILE_BLOCK(arg_node) != NULL) {
		DOWHILE_BLOCK(arg_node) = TRAVdo(DOWHILE_BLOCK(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (DOWHILE_CONDITION(arg_node) != NULL) {
		DOWHILE_CONDITION(arg_node) = TRAVdo(DOWHILE_CONDITION(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKerror(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKerror");

	/*
	 * Son check: ERROR_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (ERROR_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(ERROR_NEXT(arg_node)) == N_error))) {
				CHKcorrectTypeInsertError(arg_node, "ERROR_NEXT hasnt the right type." " It should be: " "N_error");
			}
		}
	} else {
		CHKnotExist(ERROR_NEXT(arg_node), arg_node, "attribute ERROR_NEXT must be NULL");
	}

	/*
	 * Attribute check: ERROR_MESSAGE
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(ERROR_MESSAGE(arg_node), arg_node, "mandatory attribute ERROR_MESSAGE is NULL");
	} else {
		CHKnotExist(ERROR_MESSAGE(arg_node), arg_node, "attribute ERROR_MESSAGE must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (ERROR_NEXT(arg_node) != NULL) {
		ERROR_NEXT(arg_node) = TRAVdo(ERROR_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKexpressions
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Expressions node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKexpressions(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKexpressions");

	/*
	 * Son check: EXPRESSIONS_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(EXPRESSIONS_EXPR(arg_node), arg_node, "mandatory son EXPRESSIONS_EXPR is NULL");
		if (EXPRESSIONS_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(EXPRESSIONS_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "EXPRESSIONS_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(EXPRESSIONS_EXPR(arg_node), arg_node, "attribute EXPRESSIONS_EXPR must be NULL");
	}

	/*
	 * Son check: EXPRESSIONS_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (EXPRESSIONS_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(EXPRESSIONS_NEXT(arg_node)) == N_expressions))) {
				CHKcorrectTypeInsertError(arg_node, "EXPRESSIONS_NEXT hasnt the right type." " It should be: " "N_expressions");
			}
		}
	} else {
		CHKnotExist(EXPRESSIONS_NEXT(arg_node), arg_node, "attribute EXPRESSIONS_NEXT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (EXPRESSIONS_EXPR(arg_node) != NULL) {
		EXPRESSIONS_EXPR(arg_node) = TRAVdo(EXPRESSIONS_EXPR(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (EXPRESSIONS_NEXT(arg_node) != NULL) {
		EXPRESSIONS_NEXT(arg_node) = TRAVdo(EXPRESSIONS_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfloat(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfloat");
	DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfor(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfor");

	/*
	 * Son check: FOR_BLOCK
	 */
	if ((FALSE) || (TRUE)) {
		if (FOR_BLOCK(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FOR_BLOCK(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "FOR_BLOCK hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(FOR_BLOCK(arg_node), arg_node, "attribute FOR_BLOCK must be NULL");
	}

	/*
	 * Son check: FOR_FIRST
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FOR_FIRST(arg_node), arg_node, "mandatory son FOR_FIRST is NULL");
		if (FOR_FIRST(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(FOR_FIRST(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "FOR_FIRST hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(FOR_FIRST(arg_node), arg_node, "attribute FOR_FIRST must be NULL");
	}

	/*
	 * Son check: FOR_SECOND
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FOR_SECOND(arg_node), arg_node, "mandatory son FOR_SECOND is NULL");
		if (FOR_SECOND(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(FOR_SECOND(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "FOR_SECOND hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(FOR_SECOND(arg_node), arg_node, "attribute FOR_SECOND must be NULL");
	}

	/*
	 * Son check: FOR_THIRD
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FOR_THIRD(arg_node), arg_node, "mandatory son FOR_THIRD is NULL");
		if (FOR_THIRD(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(FOR_THIRD(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "FOR_THIRD hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(FOR_THIRD(arg_node), arg_node, "attribute FOR_THIRD must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FOR_BLOCK(arg_node) != NULL) {
		FOR_BLOCK(arg_node) = TRAVdo(FOR_BLOCK(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FOR_FIRST(arg_node) != NULL) {
		FOR_FIRST(arg_node) = TRAVdo(FOR_FIRST(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FOR_SECOND(arg_node) != NULL) {
		FOR_SECOND(arg_node) = TRAVdo(FOR_SECOND(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FOR_THIRD(arg_node) != NULL) {
		FOR_THIRD(arg_node) = TRAVdo(FOR_THIRD(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfunbody(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfunbody");

	/*
	 * Son check: FUNBODY_LOCALFUNDEFS
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNBODY_LOCALFUNDEFS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNBODY_LOCALFUNDEFS(arg_node)) == N_fundefs))) {
				CHKcorrectTypeInsertError(arg_node, "FUNBODY_LOCALFUNDEFS hasnt the right type." " It should be: " "N_fundefs");
			}
		}
	} else {
		CHKnotExist(FUNBODY_LOCALFUNDEFS(arg_node), arg_node, "attribute FUNBODY_LOCALFUNDEFS must be NULL");
	}

	/*
	 * Son check: FUNBODY_STMTS
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNBODY_STMTS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNBODY_STMTS(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "FUNBODY_STMTS hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(FUNBODY_STMTS(arg_node), arg_node, "attribute FUNBODY_STMTS must be NULL");
	}

	/*
	 * Son check: FUNBODY_VARDEC
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNBODY_VARDEC(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNBODY_VARDEC(arg_node)) == N_vardec))) {
				CHKcorrectTypeInsertError(arg_node, "FUNBODY_VARDEC hasnt the right type." " It should be: " "N_vardec");
			}
		}
	} else {
		CHKnotExist(FUNBODY_VARDEC(arg_node), arg_node, "attribute FUNBODY_VARDEC must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNBODY_LOCALFUNDEFS(arg_node) != NULL) {
		FUNBODY_LOCALFUNDEFS(arg_node) = TRAVdo(FUNBODY_LOCALFUNDEFS(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNBODY_STMTS(arg_node) != NULL) {
		FUNBODY_STMTS(arg_node) = TRAVdo(FUNBODY_STMTS(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNBODY_VARDEC(arg_node) != NULL) {
		FUNBODY_VARDEC(arg_node) = TRAVdo(FUNBODY_VARDEC(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfundec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfundec(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfundec");

	/*
	 * Son check: FUNDEC_FUNHEADER
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FUNDEC_FUNHEADER(arg_node), arg_node, "mandatory son FUNDEC_FUNHEADER is NULL");
		if (FUNDEC_FUNHEADER(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEC_FUNHEADER(arg_node)) == N_funheader))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEC_FUNHEADER hasnt the right type." " It should be: " "N_funheader");
			}
		}
	} else {
		CHKnotExist(FUNDEC_FUNHEADER(arg_node), arg_node, "attribute FUNDEC_FUNHEADER must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEC_FUNHEADER(arg_node) != NULL) {
		FUNDEC_FUNHEADER(arg_node) = TRAVdo(FUNDEC_FUNHEADER(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfundef(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfundef");

	/*
	 * Son check: FUNDEF_FUNBODY
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FUNDEF_FUNBODY(arg_node), arg_node, "mandatory son FUNDEF_FUNBODY is NULL");
		if (FUNDEF_FUNBODY(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEF_FUNBODY(arg_node)) == N_funbody))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEF_FUNBODY hasnt the right type." " It should be: " "N_funbody");
			}
		}
	} else {
		CHKnotExist(FUNDEF_FUNBODY(arg_node), arg_node, "attribute FUNDEF_FUNBODY must be NULL");
	}

	/*
	 * Son check: FUNDEF_FUNHEADER
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FUNDEF_FUNHEADER(arg_node), arg_node, "mandatory son FUNDEF_FUNHEADER is NULL");
		if (FUNDEF_FUNHEADER(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEF_FUNHEADER(arg_node)) == N_funheader))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEF_FUNHEADER hasnt the right type." " It should be: " "N_funheader");
			}
		}
	} else {
		CHKnotExist(FUNDEF_FUNHEADER(arg_node), arg_node, "attribute FUNDEF_FUNHEADER must be NULL");
	}

	/*
	 * Son check: FUNDEF_PARAMS
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNDEF_PARAMS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEF_PARAMS(arg_node)) == N_param))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEF_PARAMS hasnt the right type." " It should be: " "N_param");
			}
		}
	} else {
		CHKnotExist(FUNDEF_PARAMS(arg_node), arg_node, "attribute FUNDEF_PARAMS must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEF_FUNBODY(arg_node) != NULL) {
		FUNDEF_FUNBODY(arg_node) = TRAVdo(FUNDEF_FUNBODY(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEF_FUNHEADER(arg_node) != NULL) {
		FUNDEF_FUNHEADER(arg_node) = TRAVdo(FUNDEF_FUNHEADER(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEF_PARAMS(arg_node) != NULL) {
		FUNDEF_PARAMS(arg_node) = TRAVdo(FUNDEF_PARAMS(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfundefs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDefs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfundefs(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfundefs");

	/*
	 * Son check: FUNDEFS_FUNDEF
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FUNDEFS_FUNDEF(arg_node), arg_node, "mandatory son FUNDEFS_FUNDEF is NULL");
		if (FUNDEFS_FUNDEF(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEFS_FUNDEF(arg_node)) == N_fundef))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEFS_FUNDEF hasnt the right type." " It should be: " "N_fundef");
			}
		}
	} else {
		CHKnotExist(FUNDEFS_FUNDEF(arg_node), arg_node, "attribute FUNDEFS_FUNDEF must be NULL");
	}

	/*
	 * Son check: FUNDEFS_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNDEFS_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEFS_NEXT(arg_node)) == N_fundefs))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEFS_NEXT hasnt the right type." " It should be: " "N_fundefs");
			}
		}
	} else {
		CHKnotExist(FUNDEFS_NEXT(arg_node), arg_node, "attribute FUNDEFS_NEXT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEFS_FUNDEF(arg_node) != NULL) {
		FUNDEFS_FUNDEF(arg_node) = TRAVdo(FUNDEFS_FUNDEF(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEFS_NEXT(arg_node) != NULL) {
		FUNDEFS_NEXT(arg_node) = TRAVdo(FUNDEFS_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfunheader
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunHeader node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfunheader(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfunheader");

	/*
	 * Son check: FUNHEADER_PARAM
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNHEADER_PARAM(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNHEADER_PARAM(arg_node)) == N_param))) {
				CHKcorrectTypeInsertError(arg_node, "FUNHEADER_PARAM hasnt the right type." " It should be: " "N_param");
			}
		}
	} else {
		CHKnotExist(FUNHEADER_PARAM(arg_node), arg_node, "attribute FUNHEADER_PARAM must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNHEADER_PARAM(arg_node) != NULL) {
		FUNHEADER_PARAM(arg_node) = TRAVdo(FUNHEADER_PARAM(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKglobaldec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKglobaldec(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKglobaldec");

	/*
	 * Son check: GLOBALDEC_IDS
	 */
	if ((FALSE) || (TRUE)) {
		if (GLOBALDEC_IDS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(GLOBALDEC_IDS(arg_node)) == N_expressions))) {
				CHKcorrectTypeInsertError(arg_node, "GLOBALDEC_IDS hasnt the right type." " It should be: " "N_expressions");
			}
		}
	} else {
		CHKnotExist(GLOBALDEC_IDS(arg_node), arg_node, "attribute GLOBALDEC_IDS must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (GLOBALDEC_IDS(arg_node) != NULL) {
		GLOBALDEC_IDS(arg_node) = TRAVdo(GLOBALDEC_IDS(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKglobaldef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKglobaldef(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKglobaldef");

	/*
	 * Son check: GLOBALDEF_IDS
	 */
	if ((FALSE) || (TRUE)) {
		if (GLOBALDEF_IDS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(GLOBALDEF_IDS(arg_node)) == N_expressions))) {
				CHKcorrectTypeInsertError(arg_node, "GLOBALDEF_IDS hasnt the right type." " It should be: " "N_expressions");
			}
		}
	} else {
		CHKnotExist(GLOBALDEF_IDS(arg_node), arg_node, "attribute GLOBALDEF_IDS must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (GLOBALDEF_IDS(arg_node) != NULL) {
		GLOBALDEF_IDS(arg_node) = TRAVdo(GLOBALDEF_IDS(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKids
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Ids node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKids(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKids");

	/*
	 * Son check: IDS_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		if (IDS_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(IDS_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "IDS_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(IDS_EXPR(arg_node), arg_node, "attribute IDS_EXPR must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (IDS_EXPR(arg_node) != NULL) {
		IDS_EXPR(arg_node) = TRAVdo(IDS_EXPR(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKifelse
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node IfElse node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKifelse(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKifelse");

	/*
	 * Son check: IFELSE_CONDITION
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(IFELSE_CONDITION(arg_node), arg_node, "mandatory son IFELSE_CONDITION is NULL");
		if (IFELSE_CONDITION(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(IFELSE_CONDITION(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "IFELSE_CONDITION hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(IFELSE_CONDITION(arg_node), arg_node, "attribute IFELSE_CONDITION must be NULL");
	}

	/*
	 * Son check: IFELSE_ELSE
	 */
	if ((FALSE) || (TRUE)) {
		if (IFELSE_ELSE(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(IFELSE_ELSE(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "IFELSE_ELSE hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(IFELSE_ELSE(arg_node), arg_node, "attribute IFELSE_ELSE must be NULL");
	}

	/*
	 * Son check: IFELSE_THEN
	 */
	if ((FALSE) || (TRUE)) {
		if (IFELSE_THEN(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(IFELSE_THEN(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "IFELSE_THEN hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(IFELSE_THEN(arg_node), arg_node, "attribute IFELSE_THEN must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (IFELSE_CONDITION(arg_node) != NULL) {
		IFELSE_CONDITION(arg_node) = TRAVdo(IFELSE_CONDITION(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (IFELSE_ELSE(arg_node) != NULL) {
		IFELSE_ELSE(arg_node) = TRAVdo(IFELSE_ELSE(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (IFELSE_THEN(arg_node) != NULL) {
		IFELSE_THEN(arg_node) = TRAVdo(IFELSE_THEN(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKmonop(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKmonop");

	/*
	 * Son check: MONOP_OPERAND
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(MONOP_OPERAND(arg_node), arg_node, "mandatory son MONOP_OPERAND is NULL");
		if (MONOP_OPERAND(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(MONOP_OPERAND(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "MONOP_OPERAND hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(MONOP_OPERAND(arg_node), arg_node, "attribute MONOP_OPERAND must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (MONOP_OPERAND(arg_node) != NULL) {
		MONOP_OPERAND(arg_node) = TRAVdo(MONOP_OPERAND(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKnum
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Num node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKnum(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKnum");
	DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKparam(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKparam");

	/*
	 * Son check: PARAM_ID
	 */
	if ((FALSE) || (TRUE)) {
		if (PARAM_ID(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(PARAM_ID(arg_node)) == N_ids))) {
				CHKcorrectTypeInsertError(arg_node, "PARAM_ID hasnt the right type." " It should be: " "N_ids");
			}
		}
	} else {
		CHKnotExist(PARAM_ID(arg_node), arg_node, "attribute PARAM_ID must be NULL");
	}

	/*
	 * Son check: PARAM_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (PARAM_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(PARAM_NEXT(arg_node)) == N_param))) {
				CHKcorrectTypeInsertError(arg_node, "PARAM_NEXT hasnt the right type." " It should be: " "N_param");
			}
		}
	} else {
		CHKnotExist(PARAM_NEXT(arg_node), arg_node, "attribute PARAM_NEXT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (PARAM_ID(arg_node) != NULL) {
		PARAM_ID(arg_node) = TRAVdo(PARAM_ID(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (PARAM_NEXT(arg_node) != NULL) {
		PARAM_NEXT(arg_node) = TRAVdo(PARAM_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKprogram
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Program node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKprogram(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKprogram");

	/*
	 * Son check: PROGRAM_DECLARATIONS
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(PROGRAM_DECLARATIONS(arg_node), arg_node, "mandatory son PROGRAM_DECLARATIONS is NULL");
		if (PROGRAM_DECLARATIONS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(PROGRAM_DECLARATIONS(arg_node)) == N_declarations))) {
				CHKcorrectTypeInsertError(arg_node, "PROGRAM_DECLARATIONS hasnt the right type." " It should be: " "N_declarations");
			}
		}
	} else {
		CHKnotExist(PROGRAM_DECLARATIONS(arg_node), arg_node, "attribute PROGRAM_DECLARATIONS must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (PROGRAM_DECLARATIONS(arg_node) != NULL) {
		PROGRAM_DECLARATIONS(arg_node) = TRAVdo(PROGRAM_DECLARATIONS(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKreturn(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKreturn");

	/*
	 * Son check: RETURN_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		if (RETURN_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(RETURN_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "RETURN_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(RETURN_EXPR(arg_node), arg_node, "attribute RETURN_EXPR must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (RETURN_EXPR(arg_node) != NULL) {
		RETURN_EXPR(arg_node) = TRAVdo(RETURN_EXPR(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKstmts
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Stmts node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKstmts(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKstmts");

	/*
	 * Son check: STMTS_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (STMTS_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(STMTS_NEXT(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "STMTS_NEXT hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(STMTS_NEXT(arg_node), arg_node, "attribute STMTS_NEXT must be NULL");
	}

	/*
	 * Son check: STMTS_STMT
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(STMTS_STMT(arg_node), arg_node, "mandatory son STMTS_STMT is NULL");
		if (STMTS_STMT(arg_node) != NULL) {
			if (!((FALSE) || (isStmt(STMTS_STMT(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "STMTS_STMT hasnt the right type." " It should be: " "Nodeset: Stmt");
			}
		}
	} else {
		CHKnotExist(STMTS_STMT(arg_node), arg_node, "attribute STMTS_STMT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (STMTS_NEXT(arg_node) != NULL) {
		STMTS_NEXT(arg_node) = TRAVdo(STMTS_NEXT(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (STMTS_STMT(arg_node) != NULL) {
		STMTS_STMT(arg_node) = TRAVdo(STMTS_STMT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKsymboltableentry
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTableEntry node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKsymboltableentry(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKsymboltableentry");
	DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKvar
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Var node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKvar(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKvar");

	/*
	 * Attribute check: VAR_DECL
	 */
	if ((FALSE) || (TRUE)) {
	} else {
		CHKnotExist(VAR_DECL(arg_node), arg_node, "attribute VAR_DECL must be NULL");
	}

	/*
	 * Attribute check: VAR_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(VAR_NAME(arg_node), arg_node, "mandatory attribute VAR_NAME is NULL");
	} else {
		CHKnotExist(VAR_NAME(arg_node), arg_node, "attribute VAR_NAME must be NULL");
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKvardec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKvardec(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKvardec");

	/*
	 * Son check: VARDEC_EXPRESSIONS
	 */
	if ((FALSE) || (TRUE)) {
		if (VARDEC_EXPRESSIONS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(VARDEC_EXPRESSIONS(arg_node)) == N_expressions))) {
				CHKcorrectTypeInsertError(arg_node, "VARDEC_EXPRESSIONS hasnt the right type." " It should be: " "N_expressions");
			}
		}
	} else {
		CHKnotExist(VARDEC_EXPRESSIONS(arg_node), arg_node, "attribute VARDEC_EXPRESSIONS must be NULL");
	}

	/*
	 * Son check: VARDEC_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (VARDEC_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(VARDEC_NEXT(arg_node)) == N_vardec))) {
				CHKcorrectTypeInsertError(arg_node, "VARDEC_NEXT hasnt the right type." " It should be: " "N_vardec");
			}
		}
	} else {
		CHKnotExist(VARDEC_NEXT(arg_node), arg_node, "attribute VARDEC_NEXT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (VARDEC_EXPRESSIONS(arg_node) != NULL) {
		VARDEC_EXPRESSIONS(arg_node) = TRAVdo(VARDEC_EXPRESSIONS(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (VARDEC_NEXT(arg_node) != NULL) {
		VARDEC_NEXT(arg_node) = TRAVdo(VARDEC_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKvarlet
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarLet node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKvarlet(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKvarlet");

	/*
	 * Attribute check: VARLET_DECL
	 */
	if ((FALSE) || (TRUE)) {
	} else {
		CHKnotExist(VARLET_DECL(arg_node), arg_node, "attribute VARLET_DECL must be NULL");
	}

	/*
	 * Attribute check: VARLET_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(VARLET_NAME(arg_node), arg_node, "mandatory attribute VARLET_NAME is NULL");
	} else {
		CHKnotExist(VARLET_NAME(arg_node), arg_node, "attribute VARLET_NAME must be NULL");
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKwhile(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKwhile");

	/*
	 * Son check: WHILE_BLOCK
	 */
	if ((FALSE) || (TRUE)) {
		if (WHILE_BLOCK(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(WHILE_BLOCK(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "WHILE_BLOCK hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(WHILE_BLOCK(arg_node), arg_node, "attribute WHILE_BLOCK must be NULL");
	}

	/*
	 * Son check: WHILE_CONDITION
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(WHILE_CONDITION(arg_node), arg_node, "mandatory son WHILE_CONDITION is NULL");
		if (WHILE_CONDITION(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(WHILE_CONDITION(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "WHILE_CONDITION hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(WHILE_CONDITION(arg_node), arg_node, "attribute WHILE_CONDITION must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (WHILE_BLOCK(arg_node) != NULL) {
		WHILE_BLOCK(arg_node) = TRAVdo(WHILE_BLOCK(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (WHILE_CONDITION(arg_node) != NULL) {
		WHILE_CONDITION(arg_node) = TRAVdo(WHILE_CONDITION(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}

typedef enum {
	CHK_binop_op,
	CHK_bool_value,
	CHK_error_message,
	CHK_float_value,
	CHK_fundec_type,
	CHK_fundef_type,
	CHK_funheader_type,
	CHK_globaldec_type,
	CHK_globaldef_type,
	CHK_monop_op,
	CHK_num_value,
	CHK_param_type,
	CHK_var_name,
	CHK_vardec_type,
	CHK_varlet_name,
}		attr_list;

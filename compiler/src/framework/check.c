
/**
 * @file check.c
 *
 * Functions needed by check.
 *
 * THIS FILE HAS BEEN GENERATED USING
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node           *
CHKdoTreeCheck(node * syntax_tree)
{
	DBUG_ENTER("CHKdoTreeCheck");

	DBUG_PRINT("CHK", ("Starting the check mechanism"));

	TRAVpush(TR_chk);
	syntax_tree = TRAVdo(syntax_tree, NULL);
	TRAVpop();

	DBUG_PRINT("CHK", ("Checkmechanism complete"));

	DBUG_RETURN(syntax_tree);
}

static bool 
isDecl(node * arg_node)
{
	bool		res = ((NODE_TYPE(arg_node) == N_fundec) ||
		     (NODE_TYPE(arg_node) == N_fundef) ||
		     (NODE_TYPE(arg_node) == N_globdec) ||
		     (NODE_TYPE(arg_node) == N_globdef));
	return (res);
}
static bool 
isExpr(node * arg_node)
{
	bool		res = ((NODE_TYPE(arg_node) == N_binop) ||
		     (NODE_TYPE(arg_node) == N_bool) ||
		     (NODE_TYPE(arg_node) == N_float) ||
		     (NODE_TYPE(arg_node) == N_num) ||
		     (NODE_TYPE(arg_node) == N_var));
	return (res);
}
static bool 
isStmt(node * arg_node)
{
	bool		res = ((NODE_TYPE(arg_node) == N_assign) ||
		     (NODE_TYPE(arg_node) == N_dowhile) ||
		     (NODE_TYPE(arg_node) == N_exprstmt) ||
		     (NODE_TYPE(arg_node) == N_for) ||
		     (NODE_TYPE(arg_node) == N_ifelse) ||
		     (NODE_TYPE(arg_node) == N_return) ||
		     (NODE_TYPE(arg_node) == N_while));
	return (res);
}
void		isDummy   () {
	isDecl(NULL);
	isExpr(NULL);
	isStmt(NULL);
}
/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKassign(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKassign");

	/*
	 * Son check: ASSIGN_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(ASSIGN_EXPR(arg_node), arg_node, "mandatory son ASSIGN_EXPR is NULL");
		if (ASSIGN_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(ASSIGN_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "ASSIGN_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(ASSIGN_EXPR(arg_node), arg_node, "attribute ASSIGN_EXPR must be NULL");
	}

	/*
	 * Son check: ASSIGN_LET
	 */
	if ((FALSE) || (TRUE)) {
		if (ASSIGN_LET(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(ASSIGN_LET(arg_node)) == N_varlet))) {
				CHKcorrectTypeInsertError(arg_node, "ASSIGN_LET hasnt the right type." " It should be: " "N_varlet");
			}
		}
	} else {
		CHKnotExist(ASSIGN_LET(arg_node), arg_node, "attribute ASSIGN_LET must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (ASSIGN_EXPR(arg_node) != NULL) {
		ASSIGN_EXPR(arg_node) = TRAVdo(ASSIGN_EXPR(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (ASSIGN_LET(arg_node) != NULL) {
		ASSIGN_LET(arg_node) = TRAVdo(ASSIGN_LET(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKbinop(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKbinop");

	/*
	 * Son check: BINOP_LEFT
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(BINOP_LEFT(arg_node), arg_node, "mandatory son BINOP_LEFT is NULL");
		if (BINOP_LEFT(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(BINOP_LEFT(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "BINOP_LEFT hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(BINOP_LEFT(arg_node), arg_node, "attribute BINOP_LEFT must be NULL");
	}

	/*
	 * Son check: BINOP_RIGHT
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(BINOP_RIGHT(arg_node), arg_node, "mandatory son BINOP_RIGHT is NULL");
		if (BINOP_RIGHT(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(BINOP_RIGHT(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "BINOP_RIGHT hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(BINOP_RIGHT(arg_node), arg_node, "attribute BINOP_RIGHT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (BINOP_LEFT(arg_node) != NULL) {
		BINOP_LEFT(arg_node) = TRAVdo(BINOP_LEFT(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (BINOP_RIGHT(arg_node) != NULL) {
		BINOP_RIGHT(arg_node) = TRAVdo(BINOP_RIGHT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKbool(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKbool");
	DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKbsctype
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BscType node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKbsctype(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKbsctype");

	/*
	 * Son check: BSCTYPE_BOOL
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(BSCTYPE_BOOL(arg_node), arg_node, "mandatory son BSCTYPE_BOOL is NULL");
		if (BSCTYPE_BOOL(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(BSCTYPE_BOOL(arg_node)) == N_bool))) {
				CHKcorrectTypeInsertError(arg_node, "BSCTYPE_BOOL hasnt the right type." " It should be: " "N_bool");
			}
		}
	} else {
		CHKnotExist(BSCTYPE_BOOL(arg_node), arg_node, "attribute BSCTYPE_BOOL must be NULL");
	}

	/*
	 * Son check: BSCTYPE_FLOAT
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(BSCTYPE_FLOAT(arg_node), arg_node, "mandatory son BSCTYPE_FLOAT is NULL");
		if (BSCTYPE_FLOAT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(BSCTYPE_FLOAT(arg_node)) == N_float))) {
				CHKcorrectTypeInsertError(arg_node, "BSCTYPE_FLOAT hasnt the right type." " It should be: " "N_float");
			}
		}
	} else {
		CHKnotExist(BSCTYPE_FLOAT(arg_node), arg_node, "attribute BSCTYPE_FLOAT must be NULL");
	}

	/*
	 * Son check: BSCTYPE_NUM
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(BSCTYPE_NUM(arg_node), arg_node, "mandatory son BSCTYPE_NUM is NULL");
		if (BSCTYPE_NUM(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(BSCTYPE_NUM(arg_node)) == N_num))) {
				CHKcorrectTypeInsertError(arg_node, "BSCTYPE_NUM hasnt the right type." " It should be: " "N_num");
			}
		}
	} else {
		CHKnotExist(BSCTYPE_NUM(arg_node), arg_node, "attribute BSCTYPE_NUM must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (BSCTYPE_BOOL(arg_node) != NULL) {
		BSCTYPE_BOOL(arg_node) = TRAVdo(BSCTYPE_BOOL(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (BSCTYPE_FLOAT(arg_node) != NULL) {
		BSCTYPE_FLOAT(arg_node) = TRAVdo(BSCTYPE_FLOAT(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (BSCTYPE_NUM(arg_node) != NULL) {
		BSCTYPE_NUM(arg_node) = TRAVdo(BSCTYPE_NUM(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKdecls
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Decls node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKdecls(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKdecls");

	/*
	 * Son check: DECLS_DECL
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(DECLS_DECL(arg_node), arg_node, "mandatory son DECLS_DECL is NULL");
		if (DECLS_DECL(arg_node) != NULL) {
			if (!((FALSE) || (isDecl(DECLS_DECL(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "DECLS_DECL hasnt the right type." " It should be: " "Nodeset: Decl");
			}
		}
	} else {
		CHKnotExist(DECLS_DECL(arg_node), arg_node, "attribute DECLS_DECL must be NULL");
	}

	/*
	 * Son check: DECLS_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (DECLS_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(DECLS_NEXT(arg_node)) == N_decls))) {
				CHKcorrectTypeInsertError(arg_node, "DECLS_NEXT hasnt the right type." " It should be: " "N_decls");
			}
		}
	} else {
		CHKnotExist(DECLS_NEXT(arg_node), arg_node, "attribute DECLS_NEXT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (DECLS_DECL(arg_node) != NULL) {
		DECLS_DECL(arg_node) = TRAVdo(DECLS_DECL(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (DECLS_NEXT(arg_node) != NULL) {
		DECLS_NEXT(arg_node) = TRAVdo(DECLS_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKdowhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhile node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKdowhile(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKdowhile");

	/*
	 * Son check: DOWHILE_BLOCK
	 */
	if ((FALSE) || (TRUE)) {
		if (DOWHILE_BLOCK(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(DOWHILE_BLOCK(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "DOWHILE_BLOCK hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(DOWHILE_BLOCK(arg_node), arg_node, "attribute DOWHILE_BLOCK must be NULL");
	}

	/*
	 * Son check: DOWHILE_COND
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(DOWHILE_COND(arg_node), arg_node, "mandatory son DOWHILE_COND is NULL");
		if (DOWHILE_COND(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(DOWHILE_COND(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "DOWHILE_COND hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(DOWHILE_COND(arg_node), arg_node, "attribute DOWHILE_COND must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (DOWHILE_BLOCK(arg_node) != NULL) {
		DOWHILE_BLOCK(arg_node) = TRAVdo(DOWHILE_BLOCK(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (DOWHILE_COND(arg_node) != NULL) {
		DOWHILE_COND(arg_node) = TRAVdo(DOWHILE_COND(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKerror(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKerror");

	/*
	 * Son check: ERROR_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (ERROR_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(ERROR_NEXT(arg_node)) == N_error))) {
				CHKcorrectTypeInsertError(arg_node, "ERROR_NEXT hasnt the right type." " It should be: " "N_error");
			}
		}
	} else {
		CHKnotExist(ERROR_NEXT(arg_node), arg_node, "attribute ERROR_NEXT must be NULL");
	}

	/*
	 * Attribute check: ERROR_MESSAGE
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(ERROR_MESSAGE(arg_node), arg_node, "mandatory attribute ERROR_MESSAGE is NULL");
	} else {
		CHKnotExist(ERROR_MESSAGE(arg_node), arg_node, "attribute ERROR_MESSAGE must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (ERROR_NEXT(arg_node) != NULL) {
		ERROR_NEXT(arg_node) = TRAVdo(ERROR_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKexprstmt
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ExprStmt node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKexprstmt(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKexprstmt");

	/*
	 * Son check: EXPRSTMT_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(EXPRSTMT_EXPR(arg_node), arg_node, "mandatory son EXPRSTMT_EXPR is NULL");
		if (EXPRSTMT_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(EXPRSTMT_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "EXPRSTMT_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(EXPRSTMT_EXPR(arg_node), arg_node, "attribute EXPRSTMT_EXPR must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (EXPRSTMT_EXPR(arg_node) != NULL) {
		EXPRSTMT_EXPR(arg_node) = TRAVdo(EXPRSTMT_EXPR(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfloat(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfloat");
	DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfor(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfor");

	/*
	 * Son check: FOR_BLOCK
	 */
	if ((FALSE) || (TRUE)) {
		if (FOR_BLOCK(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FOR_BLOCK(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "FOR_BLOCK hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(FOR_BLOCK(arg_node), arg_node, "attribute FOR_BLOCK must be NULL");
	}

	/*
	 * Son check: FOR_START
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FOR_START(arg_node), arg_node, "mandatory son FOR_START is NULL");
		if (FOR_START(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(FOR_START(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "FOR_START hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(FOR_START(arg_node), arg_node, "attribute FOR_START must be NULL");
	}

	/*
	 * Son check: FOR_STEP
	 */
	if ((FALSE) || (TRUE)) {
		if (FOR_STEP(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(FOR_STEP(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "FOR_STEP hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(FOR_STEP(arg_node), arg_node, "attribute FOR_STEP must be NULL");
	}

	/*
	 * Son check: FOR_STOP
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FOR_STOP(arg_node), arg_node, "mandatory son FOR_STOP is NULL");
		if (FOR_STOP(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(FOR_STOP(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "FOR_STOP hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(FOR_STOP(arg_node), arg_node, "attribute FOR_STOP must be NULL");
	}

	/*
	 * Attribute check: FOR_LOOPVAR
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(FOR_LOOPVAR(arg_node), arg_node, "mandatory attribute FOR_LOOPVAR is NULL");
	} else {
		CHKnotExist(FOR_LOOPVAR(arg_node), arg_node, "attribute FOR_LOOPVAR must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FOR_BLOCK(arg_node) != NULL) {
		FOR_BLOCK(arg_node) = TRAVdo(FOR_BLOCK(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FOR_START(arg_node) != NULL) {
		FOR_START(arg_node) = TRAVdo(FOR_START(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FOR_STEP(arg_node) != NULL) {
		FOR_STEP(arg_node) = TRAVdo(FOR_STEP(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FOR_STOP(arg_node) != NULL) {
		FOR_STOP(arg_node) = TRAVdo(FOR_STOP(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfunbody(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfunbody");

	/*
	 * Son check: FUNBODY_LOCALFUNDEFS
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNBODY_LOCALFUNDEFS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNBODY_LOCALFUNDEFS(arg_node)) == N_fundefs))) {
				CHKcorrectTypeInsertError(arg_node, "FUNBODY_LOCALFUNDEFS hasnt the right type." " It should be: " "N_fundefs");
			}
		}
	} else {
		CHKnotExist(FUNBODY_LOCALFUNDEFS(arg_node), arg_node, "attribute FUNBODY_LOCALFUNDEFS must be NULL");
	}

	/*
	 * Son check: FUNBODY_STMTS
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNBODY_STMTS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNBODY_STMTS(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "FUNBODY_STMTS hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(FUNBODY_STMTS(arg_node), arg_node, "attribute FUNBODY_STMTS must be NULL");
	}

	/*
	 * Son check: FUNBODY_VARDECLS
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNBODY_VARDECLS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNBODY_VARDECLS(arg_node)) == N_vardecl))) {
				CHKcorrectTypeInsertError(arg_node, "FUNBODY_VARDECLS hasnt the right type." " It should be: " "N_vardecl");
			}
		}
	} else {
		CHKnotExist(FUNBODY_VARDECLS(arg_node), arg_node, "attribute FUNBODY_VARDECLS must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNBODY_LOCALFUNDEFS(arg_node) != NULL) {
		FUNBODY_LOCALFUNDEFS(arg_node) = TRAVdo(FUNBODY_LOCALFUNDEFS(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNBODY_STMTS(arg_node) != NULL) {
		FUNBODY_STMTS(arg_node) = TRAVdo(FUNBODY_STMTS(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNBODY_VARDECLS(arg_node) != NULL) {
		FUNBODY_VARDECLS(arg_node) = TRAVdo(FUNBODY_VARDECLS(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfundec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfundec(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfundec");

	/*
	 * Son check: FUNDEC_FUNHEADER
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FUNDEC_FUNHEADER(arg_node), arg_node, "mandatory son FUNDEC_FUNHEADER is NULL");
		if (FUNDEC_FUNHEADER(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEC_FUNHEADER(arg_node)) == N_funheader))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEC_FUNHEADER hasnt the right type." " It should be: " "N_funheader");
			}
		}
	} else {
		CHKnotExist(FUNDEC_FUNHEADER(arg_node), arg_node, "attribute FUNDEC_FUNHEADER must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEC_FUNHEADER(arg_node) != NULL) {
		FUNDEC_FUNHEADER(arg_node) = TRAVdo(FUNDEC_FUNHEADER(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfundef(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfundef");

	/*
	 * Son check: FUNDEF_FUNBODY
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNDEF_FUNBODY(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEF_FUNBODY(arg_node)) == N_funbody))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEF_FUNBODY hasnt the right type." " It should be: " "N_funbody");
			}
		}
	} else {
		CHKnotExist(FUNDEF_FUNBODY(arg_node), arg_node, "attribute FUNDEF_FUNBODY must be NULL");
	}

	/*
	 * Son check: FUNDEF_FUNHEADER
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FUNDEF_FUNHEADER(arg_node), arg_node, "mandatory son FUNDEF_FUNHEADER is NULL");
		if (FUNDEF_FUNHEADER(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEF_FUNHEADER(arg_node)) == N_funheader))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEF_FUNHEADER hasnt the right type." " It should be: " "N_funheader");
			}
		}
	} else {
		CHKnotExist(FUNDEF_FUNHEADER(arg_node), arg_node, "attribute FUNDEF_FUNHEADER must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEF_FUNBODY(arg_node) != NULL) {
		FUNDEF_FUNBODY(arg_node) = TRAVdo(FUNDEF_FUNBODY(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEF_FUNHEADER(arg_node) != NULL) {
		FUNDEF_FUNHEADER(arg_node) = TRAVdo(FUNDEF_FUNHEADER(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfundefs
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDefs node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfundefs(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfundefs");

	/*
	 * Son check: FUNDEFS_FUNDEF
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(FUNDEFS_FUNDEF(arg_node), arg_node, "mandatory son FUNDEFS_FUNDEF is NULL");
		if (FUNDEFS_FUNDEF(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEFS_FUNDEF(arg_node)) == N_fundef))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEFS_FUNDEF hasnt the right type." " It should be: " "N_fundef");
			}
		}
	} else {
		CHKnotExist(FUNDEFS_FUNDEF(arg_node), arg_node, "attribute FUNDEFS_FUNDEF must be NULL");
	}

	/*
	 * Son check: FUNDEFS_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNDEFS_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNDEFS_NEXT(arg_node)) == N_fundefs))) {
				CHKcorrectTypeInsertError(arg_node, "FUNDEFS_NEXT hasnt the right type." " It should be: " "N_fundefs");
			}
		}
	} else {
		CHKnotExist(FUNDEFS_NEXT(arg_node), arg_node, "attribute FUNDEFS_NEXT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEFS_FUNDEF(arg_node) != NULL) {
		FUNDEFS_FUNDEF(arg_node) = TRAVdo(FUNDEFS_FUNDEF(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNDEFS_NEXT(arg_node) != NULL) {
		FUNDEFS_NEXT(arg_node) = TRAVdo(FUNDEFS_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKfunheader
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunHeader node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKfunheader(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKfunheader");

	/*
	 * Son check: FUNHEADER_PARAMS
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNHEADER_PARAMS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNHEADER_PARAMS(arg_node)) == N_param))) {
				CHKcorrectTypeInsertError(arg_node, "FUNHEADER_PARAMS hasnt the right type." " It should be: " "N_param");
			}
		}
	} else {
		CHKnotExist(FUNHEADER_PARAMS(arg_node), arg_node, "attribute FUNHEADER_PARAMS must be NULL");
	}

	/*
	 * Son check: FUNHEADER_RETTYPE
	 */
	if ((FALSE) || (TRUE)) {
		if (FUNHEADER_RETTYPE(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(FUNHEADER_RETTYPE(arg_node)) == N_rettype))) {
				CHKcorrectTypeInsertError(arg_node, "FUNHEADER_RETTYPE hasnt the right type." " It should be: " "N_rettype");
			}
		}
	} else {
		CHKnotExist(FUNHEADER_RETTYPE(arg_node), arg_node, "attribute FUNHEADER_RETTYPE must be NULL");
	}

	/*
	 * Attribute check: FUNHEADER_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(FUNHEADER_NAME(arg_node), arg_node, "mandatory attribute FUNHEADER_NAME is NULL");
	} else {
		CHKnotExist(FUNHEADER_NAME(arg_node), arg_node, "attribute FUNHEADER_NAME must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (FUNHEADER_PARAMS(arg_node) != NULL) {
		FUNHEADER_PARAMS(arg_node) = TRAVdo(FUNHEADER_PARAMS(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (FUNHEADER_RETTYPE(arg_node) != NULL) {
		FUNHEADER_RETTYPE(arg_node) = TRAVdo(FUNHEADER_RETTYPE(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKglobdec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKglobdec(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKglobdec");

	/*
	 * Attribute check: GLOBDEC_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(GLOBDEC_NAME(arg_node), arg_node, "mandatory attribute GLOBDEC_NAME is NULL");
	} else {
		CHKnotExist(GLOBDEC_NAME(arg_node), arg_node, "attribute GLOBDEC_NAME must be NULL");
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKglobdef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKglobdef(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKglobdef");

	/*
	 * Son check: GLOBDEF_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		if (GLOBDEF_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(GLOBDEF_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "GLOBDEF_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(GLOBDEF_EXPR(arg_node), arg_node, "attribute GLOBDEF_EXPR must be NULL");
	}

	/*
	 * Attribute check: GLOBDEF_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(GLOBDEF_NAME(arg_node), arg_node, "mandatory attribute GLOBDEF_NAME is NULL");
	} else {
		CHKnotExist(GLOBDEF_NAME(arg_node), arg_node, "attribute GLOBDEF_NAME must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (GLOBDEF_EXPR(arg_node) != NULL) {
		GLOBDEF_EXPR(arg_node) = TRAVdo(GLOBDEF_EXPR(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKifelse
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node IfElse node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKifelse(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKifelse");

	/*
	 * Son check: IFELSE_COND
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(IFELSE_COND(arg_node), arg_node, "mandatory son IFELSE_COND is NULL");
		if (IFELSE_COND(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(IFELSE_COND(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "IFELSE_COND hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(IFELSE_COND(arg_node), arg_node, "attribute IFELSE_COND must be NULL");
	}

	/*
	 * Son check: IFELSE_ELSE
	 */
	if ((FALSE) || (TRUE)) {
		if (IFELSE_ELSE(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(IFELSE_ELSE(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "IFELSE_ELSE hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(IFELSE_ELSE(arg_node), arg_node, "attribute IFELSE_ELSE must be NULL");
	}

	/*
	 * Son check: IFELSE_THEN
	 */
	if ((FALSE) || (TRUE)) {
		if (IFELSE_THEN(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(IFELSE_THEN(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "IFELSE_THEN hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(IFELSE_THEN(arg_node), arg_node, "attribute IFELSE_THEN must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (IFELSE_COND(arg_node) != NULL) {
		IFELSE_COND(arg_node) = TRAVdo(IFELSE_COND(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (IFELSE_ELSE(arg_node) != NULL) {
		IFELSE_ELSE(arg_node) = TRAVdo(IFELSE_ELSE(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (IFELSE_THEN(arg_node) != NULL) {
		IFELSE_THEN(arg_node) = TRAVdo(IFELSE_THEN(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKnum
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Num node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKnum(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKnum");
	DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKparam(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKparam");

	/*
	 * Attribute check: PARAM_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(PARAM_NAME(arg_node), arg_node, "mandatory attribute PARAM_NAME is NULL");
	} else {
		CHKnotExist(PARAM_NAME(arg_node), arg_node, "attribute PARAM_NAME must be NULL");
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKprogram
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Program node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKprogram(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKprogram");

	/*
	 * Son check: PROGRAM_DECLS
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(PROGRAM_DECLS(arg_node), arg_node, "mandatory son PROGRAM_DECLS is NULL");
		if (PROGRAM_DECLS(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(PROGRAM_DECLS(arg_node)) == N_decls))) {
				CHKcorrectTypeInsertError(arg_node, "PROGRAM_DECLS hasnt the right type." " It should be: " "N_decls");
			}
		}
	} else {
		CHKnotExist(PROGRAM_DECLS(arg_node), arg_node, "attribute PROGRAM_DECLS must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (PROGRAM_DECLS(arg_node) != NULL) {
		PROGRAM_DECLS(arg_node) = TRAVdo(PROGRAM_DECLS(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKrettype
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node RetType node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKrettype(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKrettype");

	/*
	 * Son check: RETTYPE_BSCTYPE
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(RETTYPE_BSCTYPE(arg_node), arg_node, "mandatory son RETTYPE_BSCTYPE is NULL");
		if (RETTYPE_BSCTYPE(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(RETTYPE_BSCTYPE(arg_node)) == N_bsctype))) {
				CHKcorrectTypeInsertError(arg_node, "RETTYPE_BSCTYPE hasnt the right type." " It should be: " "N_bsctype");
			}
		}
	} else {
		CHKnotExist(RETTYPE_BSCTYPE(arg_node), arg_node, "attribute RETTYPE_BSCTYPE must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (RETTYPE_BSCTYPE(arg_node) != NULL) {
		RETTYPE_BSCTYPE(arg_node) = TRAVdo(RETTYPE_BSCTYPE(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKreturn(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKreturn");

	/*
	 * Son check: RETURN_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		if (RETURN_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(RETURN_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "RETURN_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(RETURN_EXPR(arg_node), arg_node, "attribute RETURN_EXPR must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (RETURN_EXPR(arg_node) != NULL) {
		RETURN_EXPR(arg_node) = TRAVdo(RETURN_EXPR(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKstmts
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Stmts node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKstmts(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKstmts");

	/*
	 * Son check: STMTS_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (STMTS_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(STMTS_NEXT(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "STMTS_NEXT hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(STMTS_NEXT(arg_node), arg_node, "attribute STMTS_NEXT must be NULL");
	}

	/*
	 * Son check: STMTS_STMT
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(STMTS_STMT(arg_node), arg_node, "mandatory son STMTS_STMT is NULL");
		if (STMTS_STMT(arg_node) != NULL) {
			if (!((FALSE) || (isStmt(STMTS_STMT(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "STMTS_STMT hasnt the right type." " It should be: " "Nodeset: Stmt");
			}
		}
	} else {
		CHKnotExist(STMTS_STMT(arg_node), arg_node, "attribute STMTS_STMT must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (STMTS_NEXT(arg_node) != NULL) {
		STMTS_NEXT(arg_node) = TRAVdo(STMTS_NEXT(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (STMTS_STMT(arg_node) != NULL) {
		STMTS_STMT(arg_node) = TRAVdo(STMTS_STMT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKsymboltableentry
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTableEntry node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKsymboltableentry(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKsymboltableentry");
	DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKvar
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Var node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKvar(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKvar");

	/*
	 * Attribute check: VAR_DECL
	 */
	if ((FALSE) || (TRUE)) {
	} else {
		CHKnotExist(VAR_DECL(arg_node), arg_node, "attribute VAR_DECL must be NULL");
	}

	/*
	 * Attribute check: VAR_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(VAR_NAME(arg_node), arg_node, "mandatory attribute VAR_NAME is NULL");
	} else {
		CHKnotExist(VAR_NAME(arg_node), arg_node, "attribute VAR_NAME must be NULL");
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKvardecl
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDecl node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKvardecl(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKvardecl");

	/*
	 * Son check: VARDECL_EXPR
	 */
	if ((FALSE) || (TRUE)) {
		if (VARDECL_EXPR(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(VARDECL_EXPR(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "VARDECL_EXPR hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(VARDECL_EXPR(arg_node), arg_node, "attribute VARDECL_EXPR must be NULL");
	}

	/*
	 * Son check: VARDECL_NEXT
	 */
	if ((FALSE) || (TRUE)) {
		if (VARDECL_NEXT(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(VARDECL_NEXT(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "VARDECL_NEXT hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(VARDECL_NEXT(arg_node), arg_node, "attribute VARDECL_NEXT must be NULL");
	}

	/*
	 * Attribute check: VARDECL_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(VARDECL_NAME(arg_node), arg_node, "mandatory attribute VARDECL_NAME is NULL");
	} else {
		CHKnotExist(VARDECL_NAME(arg_node), arg_node, "attribute VARDECL_NAME must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (VARDECL_EXPR(arg_node) != NULL) {
		VARDECL_EXPR(arg_node) = TRAVdo(VARDECL_EXPR(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (VARDECL_NEXT(arg_node) != NULL) {
		VARDECL_NEXT(arg_node) = TRAVdo(VARDECL_NEXT(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKvarlet
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarLet node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKvarlet(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKvarlet");

	/*
	 * Attribute check: VARLET_DECL
	 */
	if ((FALSE) || (TRUE)) {
	} else {
		CHKnotExist(VARLET_DECL(arg_node), arg_node, "attribute VARLET_DECL must be NULL");
	}

	/*
	 * Attribute check: VARLET_NAME
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistAttribute(VARLET_NAME(arg_node), arg_node, "mandatory attribute VARLET_NAME is NULL");
	} else {
		CHKnotExist(VARLET_NAME(arg_node), arg_node, "attribute VARLET_NAME must be NULL");
	} DBUG_RETURN(arg_node);
}
/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node           *CHKwhile(node * arg_node, info * arg_info) {
	DBUG_ENTER("CHKwhile");

	/*
	 * Son check: WHILE_BLOCK
	 */
	if ((FALSE) || (TRUE)) {
		if (WHILE_BLOCK(arg_node) != NULL) {
			if (!((FALSE) || (NODE_TYPE(WHILE_BLOCK(arg_node)) == N_stmts))) {
				CHKcorrectTypeInsertError(arg_node, "WHILE_BLOCK hasnt the right type." " It should be: " "N_stmts");
			}
		}
	} else {
		CHKnotExist(WHILE_BLOCK(arg_node), arg_node, "attribute WHILE_BLOCK must be NULL");
	}

	/*
	 * Son check: WHILE_COND
	 */
	if ((FALSE) || (TRUE)) {
		CHKexistSon(WHILE_COND(arg_node), arg_node, "mandatory son WHILE_COND is NULL");
		if (WHILE_COND(arg_node) != NULL) {
			if (!((FALSE) || (isExpr(WHILE_COND(arg_node))))) {
				CHKcorrectTypeInsertError(arg_node, "WHILE_COND hasnt the right type." " It should be: " "Nodeset: Expr");
			}
		}
	} else {
		CHKnotExist(WHILE_COND(arg_node), arg_node, "attribute WHILE_COND must be NULL");
	}

	/*
	 * trav functions: to get all sons
	 */
	if (WHILE_BLOCK(arg_node) != NULL) {
		WHILE_BLOCK(arg_node) = TRAVdo(WHILE_BLOCK(arg_node), arg_info);
	}
	/*
	 * trav functions: to get all sons
	 */
	if (WHILE_COND(arg_node) != NULL) {
		WHILE_COND(arg_node) = TRAVdo(WHILE_COND(arg_node), arg_info);
	} DBUG_RETURN(arg_node);
}

typedef enum {
	CHK_binop_op,
	CHK_bool_value,
	CHK_error_message,
	CHK_float_value,
	CHK_for_loopvar,
	CHK_funheader_type,
	CHK_globdec_name,
	CHK_globdef_name,
	CHK_num_value,
	CHK_param_name,
	CHK_var_name,
	CHK_vardecl_name,
	CHK_varlet_name,
}		attr_list;
